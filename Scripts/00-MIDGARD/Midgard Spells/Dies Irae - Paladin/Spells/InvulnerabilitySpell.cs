/***************************************************************************
 *                               InvulnerabilitySpell.cs
 *
 *   begin                : 05 maggio 2011
 *   author               :	Dies Irae
 *   email                : tocasia@alice.it
 *   copyright            : (C) Midgard Shard - Dies Irae		
 *
 ***************************************************************************/

using System;

using Midgard.Engines.Classes;

using Server;
using Server.Network;
using Server.Spells;

namespace Midgard.Engines.SpellSystem
{
    public class InvulnerabilitySpell : RPGPaladinSpell, IEffectSpell
    {
        private static readonly SpellInfo m_Info = new SpellInfo(
            "Invulnerability", "Inviolabilis",
            266,
            9002
            );

        private static readonly ExtendedSpellInfo m_ExtendedInfo = new ExtendedSpellInfo
            (
            typeof( InvulnerabilitySpell ),
            "Invulnerability",
            "During this powerful Miracle, the Paladine is immune to attackes dealt to him.",
            "Sotto l'effetto di questo Miracolo, il Paladino e' immune da ogni attacco.",
            "Per la durata dello spell il paladino è invulnerabile. La durata è (30 * level) secondi." +
            "Durante l'effetto il paladino e' effettivamente blessato quindi non puo' commettere alcuna azione ostile.",
            0x5105
            );

        public override ExtendedSpellInfo ExtendedInfo
        {
            get { return m_ExtendedInfo; }
        }

        public override string GetModificationsForChangelog()
        {
            return "Modificata la durata dell'effetto in PowerValueScaled secondi.<br>" +
                "Rimossa la frase che fa terminare l'incantesimo. Ora per farlo terminare basta rilanciarlo.";
        }

        public override SpellCircle Circle
        {
            get { return SpellCircle.Second; }
        }

        public InvulnerabilitySpell( Mobile caster, Item scroll )
            : base( caster, scroll, m_Info )
        {
        }

        public override bool CheckCast()
        {
            if( Caster == null || ( ( Caster.Hits / (double)Caster.HitsMax ) < 0.50 ) )
            {
                if( Caster != null )
                    Caster.SendLangMessage( 10000608 ); // You are too weak to invoke this power.
                FinishSequence();
                return false;
            }

            return base.CheckCast();
        }

        public override void OnCast()
        {
            if( SpellEffectContextHelper.IsUnderEffect( Caster, typeof( InvulnerabilitySpell ) ) )
            {
                SpellEffectContextHelper.RemoveContextByType( Caster, typeof( InvulnerabilitySpell ) );
                FinishSequence();
                return;
            }

            if( Caster.CanBeginAction( typeof( InvulnerabilitySpell ) ) )
            {
                if( SpellEffectContextHelper.OnCast( Caster, this ) )
                    Caster.BeginAction( typeof( InvulnerabilitySpell ) );
            }
            else
                Caster.SendLangMessage( 10000601 ); // "You cannot become invulnerable now."

            FinishSequence();
        }

        public static void RegisterOnLoginEvent()
        {
            EventSink.Login += new LoginEventHandler( OnLogin );
        }

        private static void OnLogin( LoginEventArgs e )
        {
            if( e.Mobile.AccessLevel == AccessLevel.Player && e.Mobile.Blessed && ClassSystem.IsPaladine( e.Mobile ) &&
                !SpellEffectContextHelper.IsUnderEffect( e.Mobile, typeof( InvulnerabilitySpell ) ) )
            {
                SpellEffectContextHelper.RemoveContextByType( e.Mobile, typeof( InvulnerabilitySpell ) );
            }
        }

        private static void ReleaseInvulnerabilityLock( object state )
        {
            ( (Mobile)state ).EndAction( typeof( InvulnerabilitySpell ) );
            ( (Mobile)state ).SendLangMessage( 10000602 ); // "You can recall your soul forces again."
        }

        public override int DelayOfReuseInSeconds
        {
            get { return 180; }
        }

        #region Implementation of IEffectSpell
        public void StartEffect( Mobile m )
        {
            m.PublicOverheadMessage( MessageType.Regular, 37, true, TextHelper.Text( 10000603, m.TrueLanguage ) ); // "* You are invulnerable *"
            m.FixedParticles( 0x373A, 10, 15, 5018, EffectLayer.Waist );
            m.PlaySound( 0x1EA );

            if( m.Poisoned )
                m.CurePoison( m );

            m.Blessed = true;
        }

        public void EndEffect( Mobile m )
        {
            if( m != null && !m.Deleted && ClassSystem.IsPaladine( m ) )
            {
                m.PublicOverheadMessage( MessageType.Regular, 37, true, TextHelper.Text( 10000604, m.TrueLanguage ) ); // "* You are a vulnerable being now *"
                m.FixedParticles( 0x373A, 10, 15, 5018, EffectLayer.Waist );
                m.PlaySound( 0x1EA );

                if( m.AccessLevel == AccessLevel.Player )
                    m.Blessed = false;
                else
                    m.SendLangMessage( 10000605 ); // "You remained invulnerable because of your staff status."

                Timer.DelayCall( GetDelayOfReuseInSeconds(), new TimerStateCallback( ReleaseInvulnerabilityLock ), m );
                m.SendLangMessage( 10000606, DelayOfReuseInSeconds ); // "Invulnerability will be available in {0} seconds."
            }
        }

        public double TickRate
        {
            get { return 2.5; }
        }

        public void OnTick( Mobile m )
        {
            SpellEffectContext context = SpellEffectContextHelper.GetContext( m, typeof( InvulnerabilitySpell ) );
            if( context != null && !context.Expired )
            {
                int seconds = (int)( context.ExpirationTime - DateTime.Now ).TotalSeconds;
                if( seconds > 10 && seconds % 10 == 0 )
                    m.SendLangMessage( 10000607, seconds ); // "Invulnerability will last for {0} seconds."
            }
        }

        public double DurationInMinutes
        {
            get { return PowerValueScaled / 60.0; }
        }
        #endregion
    }
}